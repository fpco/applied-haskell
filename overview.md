# Applied Haskell

* Course by FP Complete
* Presented by Michael Snoyman
* Workshop at LambdaConf 2017

## Overview

* Haskell is a "revolutionary" language
* We don't care about that today very much
* How do I get things done in Haskell?
* Focus:
    * Familiarity with best-in-class libraries
    * Get better at picking up Haskell idioms
    * Learn tooling a bit more
    * Pick up runtime system idiosyncracies

### What we won't do

* Focus on advanced features of the language
    * If they come up, we'll cover them, but they're not the focus
* Learn math or category theory
    * We just want to do enough to be proficient with common libraries
* Teach basic Haskell syntax
    * Assuming such basic familiarity as a prereq

### What you should do

* Ask questions
* Bring up real-world problems you've encountered
* This should be an interactive session as much as possible, __no one
  be shy!__

### Get started

* Gitter chat for this course
    * <https://gitter.im/applied-haskell/Lobby>
    * Good way to share code results with me
    * (My first time trying this approach, if it sucks, we'll do something
      else)
* The content I'm sharing here: <https://github.com/fpco/applied-haskell>
    * Careful: don't cheat and read the answers!
* Let's go around and introduce ourselves
* And fill out this form if you haven't please
    * <https://goo.gl/forms/BlDw2O5zQ0tBeiSH2>

### Learning Resources

* <https://www.fpcomplete.com/haskell-syllabus>
    * This course is based on the syllabus
* <https://www.stackage.org/> (and its Hoogle search)
    * We'll be using this a lot!
* <https://haskell-lang.org/libraries>
    * Much of the material is taken from these library docs
* <https://haskell-lang.org/documentation>
* <http://www.yesodweb.com/book>
* <https://www.schoolofhaskell.com>

## Tooling overview

* __GHC__ Compiler
    * GHCJS, JHC, others...
    * Almost everyone uses GHC
* __Stack__ build tool
    * Downloads GHC for you
    * Installs packages
* __Emacs__ editor
    * intero-mode works pretty well
    * And many others
* __hlint__ linter, __hoogle__ search

### Cabal packages

* Have a name and version number
* 0-1 libraries
* 0 or more executables
* 0 or more test suites
* 0 or more benchmarks
* Configured via `projectname.cabal`
* Or if you're cool: `package.yaml` and `hpack`
* Can be released as open source to Hackage

### hpack example

Source file (`app/Main.hs`):

```haskell
import Acme.Missiles

main :: IO ()
main = launchMissiles
```

hpack config file (`package.yaml`):

```yaml
name:                hello-hpack
version:             0.1.0.0

dependencies:
- base

executables:
  hello-hpack:
    dependencies:     acme-missiles
    source-dirs:      app
    main:             Main.hs
```

The `hello-hpack.cabal` file is automatically generated by Stack.

```cabal
-- This file has been generated from package.yaml by hpack version 0.17.0.
--
-- see: https://github.com/sol/hpack

name:           hello-hpack
version:        0.1.0.0
build-type:     Simple
cabal-version:  >= 1.10

executable hello-hpack
  main-is: Main.hs
  hs-source-dirs:
      app
  build-depends:
      base
    , acme-missiles
  default-language: Haskell2010
```

### Stackage snapshot

* Specifies a specific GHC version
* Specifies a collection of Cabal packages from Hackage
* Specifies build flags
* Nightly: one per day, try to take the latest version from Hackage
* LTS (Long Term Support): weekly, tries to maintain backwards
  compatibility based on PVP
* Guarantee: we got these packages to compile together and pass tests

### Stack projects

* Configured via `stack.yaml` file
* 0 or more local Cabal packages
* Specifies a *resolver*
    * Stackage snapshot (`nightly-2018-05-22`, `lts-11.10`)
    * GHC version (no extra packages)
* Can add extra deps, flag overrides, much more
* Can pull in packages from a Git repo

### stack.yaml example

```yaml
resolver: lts-11.10

# optional
packages:
- .

extra-deps:
- acme-missiles-0.3
```

### Quiz: package.yaml or stack.yaml

Figure out where this information goes

* My code needs to use the `process` package
* I want to specify an exact version of a dependency
* I know that my code will break with `bytestring < 0.10`
* I have two different packages in this project
* I want to build a package with a specific flag

### Stack script interpreter

* Useful for single-file code
* Nicely portable, just needs Stack
* We'll use it a lot in this course

### Stack script example

```haskell
#!/usr/bin/env stack
-- stack --resolver lts-11.10 script
{-# LANGUAGE OverloadedStrings #-}
import qualified Data.ByteString.Lazy.Char8 as BL8
import           Network.HTTP.Simple

main :: IO ()
main = do
    response <- httpLBS "http://httpbin.org/get"

    putStrLn $ "The status code was: " ++
               show (getResponseStatusCode response)
    print $ getResponseHeader "Content-Type" response
    BL8.putStrLn $ getResponseBody response
```

* Automatically detects dependencies from import list
* Installs GHC and packages automatically
* Ignores local config files for reproducibility

### GHCi

* REPL
* Access with `stack ghci` or `stack exec ghci`
* I'm personally GHCi-challenged, we won't use it much (if at all)
  here
